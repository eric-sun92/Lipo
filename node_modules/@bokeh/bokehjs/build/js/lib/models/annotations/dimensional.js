import { Model } from "../../model";
import { assert } from "../../core/util/assert";
import { bisect_right, bisect_right_by, sort_by } from "../../core/util/arrayable";
const { min } = Math;
export class Dimensional extends Model {
    static __name__ = "Dimensional";
    constructor(attrs) {
        super(attrs);
    }
    static {
        this.define(({ Nullable, Array, String, Number }) => ({
            ticks: [Array(Number)],
            include: [Nullable(Array(String)), null],
            exclude: [Array(String), []],
        }));
    }
    compute(value, unit, exact) {
        const { ticks, basis } = this;
        const found_unit = basis.find(({ short_name: short }) => short == unit);
        assert(found_unit != null);
        const value_in_unit = value * found_unit.factor;
        const [new_unit, new_long_unit, new_value] = (() => {
            const index = bisect_right_by(basis, value_in_unit, ({ factor }) => factor);
            if (index > 0) {
                const { short_name: new_unit, long_name: new_long_unit, factor } = basis[index - 1];
                const new_value = value_in_unit / factor;
                return [new_unit, new_long_unit, new_value];
            }
            else {
                return [unit, found_unit.long_name, value_in_unit];
            }
        })();
        exact = exact ?? ticks.length == 0;
        const preferred_value = (() => {
            if (exact) {
                return new_value;
            }
            else {
                const index = bisect_right(ticks, new_value);
                return ticks[min(index, ticks.length - 1)];
            }
        })();
        const preferred_value_raw = preferred_value * (value_in_unit / new_value);
        const scale_factor = (preferred_value_raw / value) / found_unit.factor;
        return {
            new_value: preferred_value,
            new_unit,
            new_long_unit,
            scale_factor,
            exact,
        };
    }
}
export class Metric extends Dimensional {
    static __name__ = "Metric";
    constructor(attrs) {
        super(attrs);
    }
    static {
        this.override({
            ticks: [1, 2, 5, 10, 15, 20, 25, 50, 75, 100, 125, 150, 200, 250, 500, 750],
        });
    }
    build_basis() {
        const { _basis_template, _short_name, _long_name, _tex_repr } = this;
        const { include, exclude } = this;
        const basis = _basis_template.map(([short_prefix, factor, long_prefix, tex_prefix]) => {
            return {
                short_name: `${short_prefix}${_short_name}`,
                factor,
                long_name: `${long_prefix}${_long_name}`,
                tex_repr: `${tex_prefix ?? short_prefix}${_tex_repr}`,
            };
        }).filter(({ short_name }) => {
            return (include == null || include.includes(short_name)) && !exclude.includes(short_name);
        });
        return sort_by(basis, ({ factor }) => factor);
    }
    _basis = null;
    get basis() {
        if (this._basis == null) {
            this._basis = this.build_basis();
        }
        return this._basis;
    }
    _basis_template = [
        ["Q", 1e30, "quetta", null],
        ["R", 1e27, "ronna", null],
        ["Y", 1e24, "yotta", null],
        ["Z", 1e21, "zetta", null],
        ["E", 1e18, "exa", null],
        ["P", 1e15, "peta", null],
        ["T", 1e12, "tera", null],
        ["G", 1e9, "giga", null],
        ["M", 1e6, "mega", null],
        ["k", 1e3, "kilo", null],
        ["h", 1e2, "hecto", null],
        ["", 1e0, "", null],
        ["d", 1e-1, "deci", null],
        ["c", 1e-2, "centi", null],
        ["m", 1e-3, "milli", null],
        ["Âµ", 1e-6, "micro", "\\mathrm{\\mu}"],
        ["n", 1e-9, "nano", null],
        ["p", 1e-12, "pico", null],
        ["f", 1e-15, "femto", null],
        ["a", 1e-18, "atto", null],
        ["z", 1e-21, "zepto", null],
        ["y", 1e-24, "yocto", null],
        ["r", 1e-27, "ronto", null],
        ["q", 1e-30, "quecto", null],
    ];
}
export class MetricLength extends Metric {
    static __name__ = "MetricLength";
    constructor(attrs) {
        super(attrs);
    }
    static {
        this.override({
            exclude: ["dm", "hm"],
        });
    }
    _short_name = "m";
    _long_name = "meter";
    _tex_repr = "m";
}
//# sourceMappingURL=dimensional.js.map
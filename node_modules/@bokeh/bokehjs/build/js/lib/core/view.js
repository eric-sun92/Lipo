import { Signal0, Signal } from "./signaling";
import { isArray } from "./util/types";
export class View {
    static __name__ = "View";
    removed = new Signal0(this, "removed");
    model;
    parent;
    root;
    owner;
    _ready = Promise.resolve(undefined);
    get ready() {
        return this._ready;
    }
    *children() { }
    _has_finished;
    mark_finished() {
        this._has_finished = true;
    }
    /** @internal */
    _slots = new WeakMap();
    connect(signal, slot) {
        let new_slot = this._slots.get(slot);
        if (new_slot == null) {
            new_slot = (args, sender) => {
                const promise = Promise.resolve(slot.call(this, args, sender));
                this._ready = this._ready.then(() => promise);
                if (this.root != this) {
                    this.root._ready = this.root._ready.then(() => this._ready);
                }
            };
            this._slots.set(slot, new_slot);
        }
        return signal.connect(new_slot, this);
    }
    disconnect(signal, slot) {
        return signal.disconnect(slot, this);
    }
    constructor(options) {
        const { model, parent, owner } = options;
        this.model = model;
        this.parent = parent;
        if (parent == null) {
            this.root = this;
            this.owner = owner ?? new ViewManager([this]);
        }
        else {
            this.root = parent.root;
            this.owner = this.root.owner;
        }
    }
    initialize() {
        this._has_finished = false;
    }
    async lazy_initialize() { }
    _removed = false;
    remove() {
        this.disconnect_signals();
        this.removed.emit();
        this._removed = true;
    }
    toString() {
        return `${this.model.type}View(${this.model.id})`;
    }
    serializable_state() {
        return { type: this.model.type };
    }
    get is_root() {
        return this.parent == null;
    }
    has_finished() {
        return this._has_finished;
    }
    get is_idle() {
        return this.has_finished();
    }
    connect_signals() { }
    disconnect_signals() {
        Signal.disconnect_receiver(this);
    }
    on_change(properties, fn) {
        for (const property of isArray(properties) ? properties : [properties]) {
            this.connect(property.change, fn);
        }
    }
    cursor(_sx, _sy) {
        return null;
    }
    _idle_notified = false;
    notify_finished() {
        if (!this.is_root)
            this.root.notify_finished();
        else {
            if (!this._idle_notified && this.has_finished()) {
                if (this.model.document != null) {
                    this._idle_notified = true;
                    this.model.document.notify_idle(this.model);
                }
            }
        }
    }
}
export class ViewManager {
    drop;
    static __name__ = "ViewManager";
    _roots;
    constructor(roots = [], drop) {
        this.drop = drop;
        this._roots = new Set(roots);
    }
    toString() {
        const views = [...this._roots].map((view) => `${view}`).join(", ");
        return `ViewManager(${views})`;
    }
    get(model) {
        for (const view of this._roots) {
            if (view.model == model)
                return view;
        }
        return null;
    }
    get_by_id(id) {
        for (const view of this._roots) {
            if (view.model.id == id)
                return view;
        }
        return null;
    }
    add(view) {
        this._roots.add(view);
    }
    delete(view) {
        this._roots.delete(view);
    }
    clear() {
        const drop = this.drop ?? ((view) => this.delete(view));
        for (const view of this) {
            drop(view);
        }
    }
    /* TODO (TS 5.2)
    [Symbol.dispose](): void {
      this.clear()
    }
    */
    get roots() {
        return [...this._roots];
    }
    *[Symbol.iterator]() {
        yield* this._roots;
    }
    *views() {
        yield* this.query(() => true);
    }
    *query(fn) {
        const visited = new Set();
        function* descend(view) {
            if (visited.has(view)) {
                return;
            }
            visited.add(view);
            if (fn(view)) {
                yield view;
            }
            for (const child of view.children()) {
                yield* descend(child);
            }
        }
        for (const root of this._roots) {
            yield* descend(root);
        }
    }
    query_one(fn) {
        for (const view of this.query(fn)) {
            return view;
        }
        return null;
    }
    *find(model) {
        yield* this.query((view) => view.model == model);
    }
    *find_by_id(id) {
        yield* this.query((view) => view.model.id == id);
    }
    find_one(model) {
        for (const view of this.find(model)) {
            return view;
        }
        return null;
    }
    find_one_by_id(id) {
        for (const view of this.find_by_id(id)) {
            return view;
        }
        return null;
    }
    get_one(model) {
        const view = this.find_one(model);
        if (view != null)
            return view;
        else
            throw new Error(`cannot find a view for ${model}`);
    }
    get_one_by_id(id) {
        const view = this.find_one_by_id(id);
        if (view != null)
            return view;
        else
            throw new Error(`cannot find a view for a model with '${id}' identity`);
    }
    find_all(model) {
        return [...this.find(model)];
    }
    find_all_by_id(id) {
        return [...this.find_by_id(id)];
    }
}
//# sourceMappingURL=view.js.map